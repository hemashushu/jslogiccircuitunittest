# Logic Circuit Unit Test Script Syntax

逻辑电路单元测试脚本的语法

## 注释

以 `#` 符号开头的行为注释行。在行中间的 `#` 符号开始到行尾也是注释。

## 端口列表

通常测试脚本的首行列出待测试的输入/输出端口（Pin）的（名称）列表，端口名称之间使用空格分隔，例如：

`A B Cin S Cout`

端口的顺序不重要，中间空格的数量也不重要。
程序会自动判断端口是输入端口还是输出端口，会自动获取端口的位宽。

### 双引号

端口名称必须是由 [a-zA-Z0-9_.-] 等字符组成。如果端口名称含有空格或者其他特殊符号，可以使用双引号包围起来，比如：

`A B "Carry Out"`

### 端口合并

也可以将多个输入端口或者多个输出合并为一个端口，格式多个端口名称之间使用逗号拼接，然后使用花括号把拼接后的字符串包围起来，比如：

`{A3, A2, A1, A0}`

表示把 4 个端口按照 A3, A2, A1, A0 的顺序合并，假如它们是输入端口，且位宽都是 1 位，则最后它们会形成一个 4 位位宽的输入端口。

### 端口拆分

也可以将一个多位位宽的端口拆分（只提取其中的一部分），比如：

`Out[7:0]`

假如 Out 是一个 32 位位宽的输出端口，则上面的表达式表示提取 Out 端口的低 8 位。也可以一次提取多个部分，比如：

`Out[31,20,16:15,7:0]`

表示分别提取第 31 位、第 20 位、从 15 到 16 位、从 0 到 7 位，一共提取 1 + 1 + 2 + 8 = 12 位组成一个新的数据。

### 子模块端口

子模块的输入和输出端口也可以写到端口列表里，方法是在子模块的端口名称前添加子模块的名称，比如：

`A B Q and-gate.A, xor-gate.A`

同样原理，子模块内部的子模块的端口也是可以添加到端口列表里，只需把层次型的子模块的名称串联在一起即可，比如：

`A B Cin half-adder1.Q half-adder1.and-gate.A`

## 测试数据行

首行之后的内容为测试数据行，一行一次测试数据。测试数据是各个输入端口、输出端口的数值，各数值之间使用空格分隔，比如：

```
A B Cin S Cout
0 0 0   0 0
0 1 0   1 0
1 0 0   1 0
```

上面的代码一共有 3 行测试数据，测试程序根据这些数据设置输入端口的数值，然后更新模块的信号状态/数据，然后再跟输出端口的数据作比较，如果匹配则表示该行测试通过，否则表示该行测试不通过，测试程序会中断，并显示测试不通过的行号。

对于子模块端口的数据，无论是子模块的输入端口还是输出端口，都只用于比较匹配，而不会用于设置数值。

也就是说，只有顶层模块的输入端口的数据才用于单元测试的“输入”，其他端口的数据都用于“检测”。

### 数值

测试数据（字面值）默认是 10 进制。如果想表示用 2 进制或者 16 进制，只需分别在数字前添加 `0b` 和 `0x` 前缀即可，比如：

```
A      B          C    D
0b1010 0b11110000 0xAA 0xF0F0
```

分别表示两个二进制数，和两个十六进制数。字符的大小写不重要。需要注意的是，数值**不支持**负数。

### 字符串数值

支持字符串类型的数据，比如：

```
addr MemOut
0x00 "a"
0x01 "b"
0x02 "c"
```

使用双引号把字符或者字符串包围起来，测表示产生随机值，用在输出端口时，表示该数值不检测。
* 当把输入端口数值写成一个减号（-），表示不改变该端口的值，比如：

```
A B S C
* 0 1 0
0 1 * 0
- 0 0 0
```

第一行表示 A 端口可输入任意数值（位宽自动获取），第二行的不检测 S 输出端口的值，第三行表示 A 端口不输入新的数值。

### 数值的运算

数据行除了可以写数字、字符串以及特殊数值等字面值，还可以是一个算术运算表达式，比如：

```
A       B     C             D
(1+2*3) (4^2) (0b0011 << 2) (0xff00 | 0x1234)
```

运算表达式必须放在一对括号之内，运算符支持：

+, -, *, /, % （加，减，乘，除，余）；^（幂）；&, |, ~（与，或，非）

## 循环

可以使用 `repeat` 方法重复执行一行，比如：

```
                A  B  Mul
repeat(i, 256)  i  2  (i*2)
```

表示重复数据第一行 256 次，i 是变量的名称，它的值将从 0 改变到 255。

### for 循环

如果循环体不止一行，则可以使用 for 循环，比如：

```
    A  B  Cin  {Cout, S}
for(i, 0, 16)
    i  1  0    (i+1)
    i  1  1    (i+2)
end
```

循环体以 `end` 行结束。循环也可以嵌套，比如：

```
    A  B  Cin  {Cout, S}
for(i, 0, 16)
  for(j, 0, 16)
    i  j  0    (i+j)
    i  j  1    (i+j+1)
  end
end
```

## 时序电路

时序电路的 1 个时钟周期通常包含一个电平上升和一个电平下降的总 2 个模块状态更新的过程，且一般模块的设计仅在时钟上升沿才有数据更新。但单元测试的每行数据都对应一次更新过程，于是在时钟下降沿过程那次更新的（输入输出端口）数据没测试的必要，这时可以使用 `nop` 关键字跳过一次测试，比如：

```
    reset counterOut
    0     0b1111     # posedge ↑
nop                  # negedge ↓
    0     0b0001     # posedge ↑
nop                  # negedge ↓
    0     0b0010     # posedge ↑
```

也可以使用 `nap(number)` 表示跳过多次更新。

## 头信息

在单元测试脚本的端口列表行之前，可以存在一段头信息（Front-Matter）。头信息主要用于改变顶层模块的默认值，以及指示测试程序的行为。头信息以一行 3 个连续的减号开始，然后以一行 3 个连续的减号结束。例如：

```
---
front-matter
---
A B Q
0 0 0
0 1 1
```

### 设定模块的默认值

每个逻辑模块都有可能拥有默认值参数，默认情况下，测试程序使用默认值来实例化该逻辑模块，如果想改变实例化的参数，则可以把实际参数写到头信息里。比如：

```
---
bitWidth: 8
inputPinNumber: 4
---
A0 B0 Q0
0  1  0
```

### 指示测试程序的行为

可以在头信息里添加 `!seq: true` 一行用于指示测试数据用于测试时序电路，这样测试程序只检查时钟的电平上升沿之后模块的（稳定的）信号状态/数据，比如：

```
---
!seq: true
bitWidth: 4
---
reset counterOut
0     0b1111     # posedge ↑
0     0b0000     # posedge ↑
0     0b0001     # posedge ↑
0     0b0010     # posedge ↑
```

注意这时 `nop` 关键字表示跳过一次时钟周期，而不是跳过一次更新（半个时钟周期），`nop(number)` 则表示跳过指定个时钟周期。