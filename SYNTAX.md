# Logic Circuit Unit Test Script Syntax

逻辑电路单元测试脚本的语法

## 注释

以 `#` 符号开头的行为注释行。在行中间的 `#` 符号开始到行尾也是注释。

## 端口列表

通常测试脚本的首行列出待测试的输入/输出端口（Pin）的（名称）列表，端口名称之间使用空格分隔，例如：

`A B Cin S Cout`

端口的顺序不重要，中间空格的数量也不重要。
程序会自动判断端口是输入端口还是输出端口，会自动获取端口的位宽。

### 端口名称

端口名称只允许 [a-zA-Z0-9_\$] 字符组成，且只能由 [a-zA-Z_] 开头。端口名称可以使用双引号包围起来，也可以不使用。比如：

`A B "Carry$Out" _Q In01`

### 端口切片

也可以只使用一个多位位宽的端口的其中一部分，例如 Out 是一个 32 位位宽的输出端口，如果只想提取低 8 位数据，可以这样写：

`Out[7:0]`

范围值先写高位，然后再写低位，中间用冒号分隔。也可以只提取其中的一位，比如 `Out[4]`，还可以一次提取多个部分，实现重组，比如：

`Out[31,20,16:15,7:0]`

表示分别提取第 31 位、第 20 位、从 15 到 16 位、从 0 到 7 位，一共提取 1 + 1 + 2 + 8 = 12 位组成一个新的数据。范围值可以有重叠，范围值的顺序也不重要。

### 端口合并

也可以将多个输入端口或者多个输出合并为一个端口，格式是多个端口名称之间使用逗号拼接，然后使用花括号把拼接后的字符串包围起来，比如：

`{A3, A2, A1, A0}`

表示把 4 个端口按照 A3, A2, A1, A0 的顺序合并，假如它们是输入端口，且位宽都是 1 位，则最后它们会形成一个 4 位位宽的输入端口。

端口合并里的端口允许端口切片，比如：

`{A, B[7:0], Cin[5,3]}`

合并端口有如下限制：
* 合并端口里不允许嵌套合并端口。
* 不能取合并端口的切片。

### 端口覆盖

如果某个端口在列表里作为输入端口出现多次，包括在端口切片、端口合并里，且数据范围有重叠，后面的赋值会覆盖前面的值。比如：

```
A[4:0]  A[7:0] B  {Cin, B}   Q
0b1111  0      1  0b01100    0b1111
```

上面的端口列表一共有 5 个端口，其中前 4 个是输入端口。
第 2 个端口跟第 1 个端口都是输入端口 A， 且第 2 次的范围 `[7:0]` 跟第 1 次的范围 `[4:0]` 有重叠，所以第 1 次的赋值将会被第 2 次的覆盖。
第 4 个端口为 `Cin` 和 `B` 的组合，在给这个组合赋值时，也会覆盖第 3 个端口 `B` 所赋的值。

### 子模块端口

子模块的输入和输出端口也可以写到端口列表里，方法是在子模块的端口名称前添加子模块的名称，比如：

`and_gate.A, xor_gate.A`

子模块内部的子模块的端口也是可以添加到端口列表里，只需把层次型的子模块的名称串联在一起即可，比如：

`half_adder1.and_gate.A`

无论是端口切片还是端口合并，都允许使用子模块端口。

## 测试数据行

首行之后的内容为测试数据行，一行一次测试数据。测试数据是各个输入端口、输出端口的数值，各数值之间使用空格分隔，比如：

```
A B Cin S Cout
0 0 0   0 0
0 1 0   1 0
1 0 0   1 0
```

上面的代码一共有 3 行测试数据，测试程序根据这些数据设置输入端口的数值，然后更新模块的信号状态/数据，然后再跟输出端口的数据作比较，如果匹配则表示该行测试通过，否则表示该行测试不通过，测试程序会中断，并显示测试不通过的行号。

对于子模块端口的数据，无论是子模块的输入端口还是输出端口，都只用于比较匹配，而不会用于设置数值。

也就是说，只有顶层模块的输入端口的数据才用于单元测试的“输入”，其他端口的数据都用于“检测”。

### 数字数值

测试数据（字面值）默认是 10 进制。如果想表示用 2 进制或者 16 进制，只需分别在数字前添加 `0b` 和 `0x` 前缀即可，比如：

```
A      B          C    D
0b1010 0b11110000 0xAA 0xF0F0
```

分别表示两个二进制数，和两个十六进制数。字符的大小写不重要。需要注意的是，数值**不支持**负数。较长的数字可以在中间插入下划线（_）用以分段，比如：

`0b0000_1111`，`0xff00_aa00`

### 字符串数值

支持字符串类型的数据，比如：

```
addr MemOut
0x00 "a"
0x01 "b"
0x02 "c"
```

使用双引号把字符或者字符串包围起来，测试程序会以 UTF-8 编码格式把字符或者字符串转换为相应的 Uint8Array。注意端口的位宽必须是 8 的整数倍，且位宽必须跟 Uint8Array 的位宽（Uint8Array.byteLength * 8）一致。

### 特殊数值 “x”

当把输出值写成 "x" 字符时，表示不检测该输出端口的信号。比如：

```
S   R   Q _Q
0   0   x  x
0   1   0  1
1   0   1  0
1   1   x  x
```

数据行第二行的 “x” 字符表示不检测 "S" 输出端口的信号值。需要注意的是：

* “x” 字符仅可以写在输出端口。
* 只能忽略端口的完整信号值，不能部分忽略，比如这些的写法是不支持的：
  - `0b0011xx`
  - `0xffxx`

### 特殊数值 “z”

可以使用字符 “z” 表示高阻抗，比如：

```
in select out
0  0      z
1  0      z
0  1      0
1  1      1
```

字符 “z” 可以写在输入端口，也可以写在输出端口。可以在二进制或者十六进制数里掺入 `z` 字符，比如：
- `0b00zz00`
- `0xffzz11`

### 数值的运算

数据行除了可以是数字、字符串以及特殊数值等，还可以是一个算术运算表达式，比如：

```
A       B     C             D
(1+2*3) (4^2) (0b0011 << 2) (0xff00 | 0x1234)
```

算术表达式必须放在**一对括号**之内，算术表达式支持：

- 加减乘除余运算（即 `+ - * / %`）；
- 指数运算（幂运算），如： `3^2 = 9`, `2^10 = 1024`；
- 阶乘，如 `3! = 6`, `4! = 24`；
- 括号改变运算优先级，如： `(1+2) * 3 = 9`；
- 对数运算，如：
 + `log10(100) = 2`
 + `log2(1024) = 10`
 + `ln(E) = 1`
 + `log(10,100) = 2`，`log(base, n)` 表示以 base 为底的 n 的对数；
- 常用函数：
  + 绝对值 `abs`，如： `abs(-12) = 12`；
  + 平方根 `sqrt`，如： `sqrt(4) = 2`；
  + 立方根 `cbrt`，如： `cbrt(8) = 2`，`cbrt(27) = 3`；
- 支持二进制和十六进制，如 `0b1010`, `0b0001`, `0xab00`, `0xabcdef`。
- 当数值较长时，可以在数字之间加上下划线以分段，比如 `123_000_000` 表示 `123000000`，二进制和十六进制同样支持下划线分段，比如 `0b1010_0000`, `0xaa00_11ff`。
- 位运算：
  - 位或，如 `0b1100 | 0b0011 = 0b1111`；
  - 位与，如 `0b1100 & 0b0011 = 0b0000`；
  - 位取反，如 `~0b1000 = 0b(28个1)0001`，按 32 bit 整数计算；
  - 位异或，如 `0b1010 xor 0b1100 = 0b0110`，注意符号 "^" 用于指数运算；
  - 位同或，如 `0b1010 xnor 0b1100 = 0b(28个1)1001`，按 32 bit 整数计算；
  - 位左移，如 `0b0001 << 2 = 0b0100`；
  - 位算术右移，如 `0b1000 >> 2 = 0b0010`，按 32 bit 整数计算，如果最高位为 1，则算术右移时高位补入的将是 1 而不是 0；。
- 循环体里面的变量（见下节）。

## 循环

可以使用 `repeat` 语句重复执行一行，比如：

```
                A  B  Mul
repeat(256, i)  i  2  (i*2)
```

表示重复后面的测试数据 256 次，i 是变量的名称，它的值将从 0 改变到 255（即 256 - 1）。

* 重复的次数必须是一个正整数。
* 变量的名字必须是**小写**的字母和数字组成，其中第一个必须是字母。正则式为 `[a-z][a-z0-9_]*`。
* 字母 'z' 和 'x' 是保留字符，不能作为变量名。
* 变量名可以省略，这时侯语句就是单纯地重复后面的测试数据。

### for 循环

如果循环体不止一行，则可以使用 for 循环语句，比如：

```
    A  B  Cin  {Cout, S}
for(i, 0, 15)
    i  1  0    (i+1)
    i  1  1    (i+2)
end
```

循环体以 `end` 行结束。for 语句括号里面包含三个部分，分别是：变量名称、开始值、结束值。上面的脚本表示变量 i 从 0 改变到 15。

注意开始值和结束值都必须是数字，而不能是变量。

循环也可以嵌套，比如：

```
    A  B  Cin  {Cout, S}
for(i, 0, 15)
  for(j, 0, 15)
    i  j  0    (i+j)
    i  j  1    (i+j+1)
  end
end
```

## 头信息

在单元测试脚本的端口列表行之前，可以存在一段头信息（Front-Matter）。头信息主要用于改变顶层模块的默认值，以及指示测试程序的行为。头信息以一行 3 个连续的减号开始，然后以一行 3 个连续的减号结束。例如：

```
---
# front matter here
---
A B Q
0 0 0
0 1 1
```

头信息包含脚本属性和配置参数两种信息。

### 设定脚本属性

#### 脚本标题

可以在头信息里添加 `!title: This is Title` 一行用于指示脚本的标题。一个模块往往会包含一个或多个测试脚本，标题用于友好地区分脚本。如果没有指示标题，则脚本的文件名将会作为脚本的标题。

脚本标题支持本地化，比如：

```
---
!title: This is Title
!title[zh_CN]: 这是标题
---
```

#### 时序电路

测试时序电路时，可以在脚本属性中指定时钟端口，指定后测试程序会自动产生时钟信号（即重复的低电平和高电平），语法是：

`!clock: port_name`

示例：

```
---
!clock: clk
---
counterOut
0b0000     # negedge ↓
0b0000     # posedge ↑
0b0001     # negedge ↓
0b0001     # posedge ↑
0b0010     # negedge ↓
0b0010     # posedge ↑
```

时钟信号将会是一系列连续的 "0-1-0-1-0-1-..." 传递给 "clk" 引脚，注意信号从低电平（即 0）开始。

**nop 语句**

如上例所示，时序电路的 1 个时钟周期包含一个电平上升和一个电平下降的总 2 个模块状态更新的过程，但有时在时钟下降沿时输入端口的数据并没发生变化（除了时钟引脚之外），且输出的数据也不重要。也就是说，有时我们仅关心时钟上升沿之后的稳定状态的数据，这时可以使用 `nop` 语句跳过一次模块状态更新，比如：

```
---
!clock: clk
---
counterOut
nop        # negedge ↓
0b0000     # posedge ↑
nop        # negedge ↓
0b0001     # posedge ↑
nop        # negedge ↓
0b0010     # posedge ↑
```

如果要跳过多次更新，可以组合使用 `repeat` 和 `nop` 语句，如：

`repeat(20) nop`

当然也可以组合使用 `for` 和 `nop` 语句实现同样的功能，只是使用 `repeat` 语句会简洁一些。

如果只是单纯想检测在时钟上升沿或者下降沿之后的数据，也可以加上 `edge` 属性，以指定在时钟的什么电平时才检测数据，比如：

`edge: posedge`

表示只在时钟引脚为高电平（且电路信号状态稳定）时检测数据，在低电平时只改变时钟引脚的信号，其他输入引脚的信号保持不变，然后单更新一次而不检测。`edge` 属性
可能的值有：'posedge', 'negedge' 以及 'both'。

示例：

```
---
!clock: clk
!edge: posedge
---
counterOut
0b0000     # posedge ↑
0b0001     # posedge ↑
0b0010     # posedge ↑
```

这样比起使用 `nop` 语句要简洁很多。

### 设定模块的默认值

每个逻辑模块都有可能拥有默认值参数，默认情况下，测试程序使用默认值来实例化该逻辑模块，如果想改变实例化的参数，则可以把实际参数写到头信息里。比如：

```
---
bitWidth: 8
inputPinNumber: 4
---
in_0 in_1 in_2 in_3 out
0    0    0    1    0
```

参数值支持数字、布尔（Boolean）以及字符串类型，如果需要传入对象类型或者字节数组类型，需要使用外部文件，详细见下节。

#### 对象类型属性

使用固定格式： `object(file:file_name.yaml)` 可以向一个属性传入对象类型的值，其中 'file_name.yaml' 为外部 YAML 文件的路径。路径必须是相对路径（相对测试脚本所在的文件夹）。示例：

```
---
splitParts: object(file:parts.yaml)
---
in    out_1  out_0
0b00  0      0
0b01  0      1
```

#### 字节数组类型属性

有时需要向模块传入一个字节数组（Byte Array），比如向一个 ROM 传入初始内容。可以使用固定格式： `binary(file:file_name.bin)` 向一个属性传入字节数组类型的值，其中 'file_name.bin' 为外部二进制文件的路径。路径必须是相对路径（相对测试脚本所在的文件夹）。示例：

```
---
initData: binary(file:boot_loader.bin)
---
data_out
0b00000000
0b10000001
```