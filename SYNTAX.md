# Logic Circuit Unit Test Script Syntax

逻辑电路单元测试脚本的语法

## 注释

以 `#` 符号开头的行为注释行。在行中间的 `#` 符号开始到行尾也是注释。

## 端口列表

通常测试脚本的首行列出待测试的输入/输出端口（Pin）的（名称）列表，端口名称之间使用空格分隔，例如：

`A B Cin S Cout`

端口的顺序不重要，中间空格的数量也不重要。
程序会自动判断端口是输入端口还是输出端口，会自动获取端口的位宽。

### 端口名称

端口名称只允许 [a-zA-Z0-9_\$] 字符组成，且只能由 [a-zA-Z_] 开头。端口名称可以使用双引号包围起来，也可以不使用。比如：

`A B "Carry$Out" _Q In01`

### 端口切片

也可以只使用一个多位位宽的端口的其中一部分，例如 Out 是一个 32 位位宽的输出端口，如果只想提取低 8 位数据，可以这样写：

`Out[7:0]`

范围值先写高位，然后再写低位，中间用冒号分隔。也可以只提取其中的一位，比如 `Out[4]`，还可以一次提取多个部分，实现重组，比如：

`Out[31,20,16:15,7:0]`

表示分别提取第 31 位、第 20 位、从 15 到 16 位、从 0 到 7 位，一共提取 1 + 1 + 2 + 8 = 12 位组成一个新的数据。范围值可以有重叠，范围值的顺序也不重要。

### 端口合并

也可以将多个输入端口或者多个输出合并为一个端口，格式是多个端口名称之间使用逗号拼接，然后使用花括号把拼接后的字符串包围起来，比如：

`{A3, A2, A1, A0}`

表示把 4 个端口按照 A3, A2, A1, A0 的顺序合并，假如它们是输入端口，且位宽都是 1 位，则最后它们会形成一个 4 位位宽的输入端口。

端口合并里的端口允许端口切片，比如：

`{A, B[7:0], Cin[5,3]}`

合并端口有如下限制：
* 合并端口里不允许嵌套合并端口。
* 不能取合并端口的切片。

### 子模块端口

子模块的输入和输出端口也可以写到端口列表里，方法是在子模块的端口名称前添加子模块的名称，比如：

`and_gate.A, xor_gate.A`

子模块内部的子模块的端口也是可以添加到端口列表里，只需把层次型的子模块的名称串联在一起即可，比如：

`half_adder1.and_gate.A`

无论是端口切片还是端口合并，都允许使用子模块端口。

## 测试数据行

首行之后的内容为测试数据行，一行一次测试数据。测试数据是各个输入端口、输出端口的数值，各数值之间使用空格分隔，比如：

```
A B Cin S Cout
0 0 0   0 0
0 1 0   1 0
1 0 0   1 0
```

上面的代码一共有 3 行测试数据，测试程序根据这些数据设置输入端口的数值，然后更新模块的信号状态/数据，然后再跟输出端口的数据作比较，如果匹配则表示该行测试通过，否则表示该行测试不通过，测试程序会中断，并显示测试不通过的行号。

对于子模块端口的数据，无论是子模块的输入端口还是输出端口，都只用于比较匹配，而不会用于设置数值。

也就是说，只有顶层模块的输入端口的数据才用于单元测试的“输入”，其他端口的数据都用于“检测”。

### 数字数值

测试数据（字面值）默认是 10 进制。如果想表示用 2 进制或者 16 进制，只需分别在数字前添加 `0b` 和 `0x` 前缀即可，比如：

```
A      B          C    D
0b1010 0b11110000 0xAA 0xF0F0
```

分别表示两个二进制数，和两个十六进制数。字符的大小写不重要。需要注意的是，数值**不支持**负数。较长的数字可以在中间插入下划线（_）用以分段，比如：

`0b0000_1111`，`0xff00_aa00`

### 字符串数值

支持字符串类型的数据，比如：

```
addr MemOut
0x00 "a"
0x01 "b"
0x02 "c"
```

使用双引号把字符或者字符串包围起来，测试程序会以 UTF-8 编码格式把字符或者字符串转换为相应的 Uint8Array。注意端口的位宽必须是 8 的整数倍，且位宽必须跟 Uint8Array 的位宽（Uint8Array.byteLength * 8）一致。

### 特殊数值

当把输出值写成星号（*）时，表示该数值不检测。比如：

```
In0 In1 S C
0   0   1 0
0   1   * 0
0   0   0 0
```

数据行第二行的星号表示不检测 S 输出端口的值。

### 数值的运算

数据行除了可以是数字、字符串以及特殊数值等，还可以是一个算术运算表达式，比如：

```
A       B     C             D
(1+2*3) (4^2) (0b0011 << 2) (0xff00 | 0x1234)
```

算术表达式必须放在**一对括号**之内，算术表达式支持：

* 加，减，乘，除，余（+, -, *, /, % ）；
* 阶乘（!），幂（^）；
* 位运算与，或，非（&, |, ~）；
* 常用函数，如对数`log10(100) = 2`, `log2(1024) = 10`, `ln(E) = 1`, `log(10,100) = 2`，其中 `log(base, n)` 表示以 base 为底的 n 的对数；绝对值 `abs`、开方 `sqrt`、四舍五入 `round`、取整 `trunc`，如：`abs(-12) = 12`, `sqrt(4) = 2`, `round(3.14) = 3`, `round(2.718) = 3`, `trunc(3.14) = 3`, `trunc(2.718) = 2`；
* 循环体里面的变量（见下节）。

## 循环

可以使用 `repeat` 语句重复执行一行，比如：

```
                A  B  Mul
repeat(256, i)  i  2  (i*2)
```

表示重复后面的测试数据 256 次，i 是变量的名称，它的值将从 0 改变到 255（即 256 - 1）。

* 重复的次数必须是一个正整数。
* 变量的名字必须是**小写**的字母和数字组成，其中第一个必须是字母。正则式为 `[a-z][a-z0-9_]*`。
* 变量名可以省略，这时侯语句就是单纯地重复后面的测试数据。

### for 循环

如果循环体不止一行，则可以使用 for 循环语句，比如：

```
    A  B  Cin  {Cout, S}
for(i, 0, 15)
    i  1  0    (i+1)
    i  1  1    (i+2)
end
```

循环体以 `end` 行结束。for 语句括号里面包含三个部分，分别是：变量名称、开始值、结束值。上面的脚本表示变量 i 从 0 改变到 15。

注意开始值和结束值都必须是数字，而不能是变量。

循环也可以嵌套，比如：

```
    A  B  Cin  {Cout, S}
for(i, 0, 15)
  for(j, 0, 15)
    i  j  0    (i+j)
    i  j  1    (i+j+1)
  end
end
```

## 时序电路

时序电路的 1 个时钟周期通常包含一个电平上升和一个电平下降的总 2 个模块状态更新的过程，且一般模块的设计仅在时钟上升沿才有数据更新。但单元测试的每行数据都对应一次更新过程，于是在时钟下降沿过程那次更新的（输入输出端口）数据没测试的必要，这时可以使用 `nop` 语句跳过一次测试，比如：

```
    reset counterOut
    0     0b1111     # posedge ↑
nop                  # negedge ↓
    0     0b0001     # posedge ↑
nop                  # negedge ↓
    0     0b0010     # posedge ↑
```

如果要跳过多次更新，可以组合使用 `repeat` 和 `nop` 语句，如：

`repeat(20) nop`

当然也可以组合使用 `for` 和 `nop` 语句实现同样的功能，只是使用 `repeat` 语句会简洁一些。

## 头信息

在单元测试脚本的端口列表行之前，可以存在一段头信息（Front-Matter）。头信息主要用于改变顶层模块的默认值，以及指示测试程序的行为。头信息以一行 3 个连续的减号开始，然后以一行 3 个连续的减号结束。例如：

```
---
# front matter here
---
A B Q
0 0 0
0 1 1
```

### 设定模块的默认值

每个逻辑模块都有可能拥有默认值参数，默认情况下，测试程序使用默认值来实例化该逻辑模块，如果想改变实例化的参数，则可以把实际参数写到头信息里。比如：

```
---
bitWidth: 8
inputPinNumber: 4
---
A0 B0 Q0
0  1  0
```

### 指示测试程序的行为

可以在头信息里添加 `!seq: true` 一行用于指示测试数据用于测试时序电路，这样测试程序只检查时钟的电平上升沿之后模块的（稳定的）信号状态/数据，比如：

```
---
!seq: true
bitWidth: 4
---
reset counterOut
0     0b1111     # posedge ↑
0     0b0000     # posedge ↑
0     0b0001     # posedge ↑
0     0b0010     # posedge ↑
```

注意这时 `nop` 关键字表示跳过一次时钟周期，而不是跳过一次更新（半个时钟周期）。